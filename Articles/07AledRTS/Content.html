
<div class="modal-body">
    <div class="row">

        <div class="col-sm-8">

            For one of my modules, I worked on a rudimentary game's engine. It worked as a process for me to properly learn Object Orientated Programming.  It was all built from the ground up in Processing, a graphical library for Java. Despite being a graphical library, it is still very rudimentary, with things like moving screens not being built it.
            <br>
            <br>

        </div>
        <div class="col-sm-4">
            <ul>
                <li>Date: October 2018 - January 2019</li>
                <li>Client: Univeristy Project</li>
                <li>Role: Sole Programmer</li>
            </ul>
        </div>

    </div>

    <hr>
    <h2>Responsibilities</h2>
    <ul>
        <li>Everything</li>
    </ul>
    <hr>
    <h2>Challenges</h2>
    <ul>
        <li>Seperating Axis Theory</li>
        <li>Storing Level Data in JSON</li>
        <li>Creating A* Pathfinding from Scratch</li>
    </ul>
    <hr>
    Over the course of the project I worked with many complexities and used the process of working on one project that didn't matter to learn my way around it, then moving onto this project when I knew what I was doing so as to not make spaghetti code.  Particular complexities I encountered were Separating Axis Theory and A* Pathfinding.
    <br>
    <br>
    Separating Axis Theory is about detecting the collision of polygons. I simplified it for myself by limiting it to triangles, as concave polygons require a more complex algorithm. Essentially it checks the projections from the perpendicular of the lines of the shapes against each other, and if all projections overlap, then they collide, and if they don't overlap then they aren't colliding.
    <br>
    <br>
    A* Pathfinding is a method of pathfinding that breaks down the world into a grid, and assigns each piece of the grid a cost, with the cost becoming more the further from the origin it is, but cheaper the closer to the end it is, making the shortest path to the end the cheapest. A couple of problems involved processing times and separating the world into grids. Ideally, I would have spent more time optimising this system, as if a path cannot be found it takes a while to realise, and this can stop the game.
    <br>
    <br>
    There are extra bits and pieces I worked on in this process, such as persistent data through JSON Files. There's also sprite integration and a very basic opponent. Whilst technically a game, it mostly plays itself. Strategy falls down to taking the ones closer to the opponent first.  Level Customisation doesn't have a sanity check, which was a shame. It was an ambitious scope, and I'm proud of the result I made.

    <br>
    <br>
</div>